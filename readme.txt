# RDT Sender and Receiver

RDT Sender and Receiver are two programmes for handling reliable data transfer
between a sender and a receiver using the transfer control protocol (TCP)

##Installation

To install invoke make in a shell with a gcc compiler
To uninstall, invoke make clean in a shell with a gcc compiler

##Usage

To run the RDT Sender, invoke ./rdt_sender <hostname> <port> <FILE>
To run the RDT Receiver, invoke ./rdt_receiver <port> <FILE_RECVD>

##Overview

This is an implementation of TCP that includes pipelining and congestion control. The sender
sends packets according to window size, which is set by the slow start and congestion avoidance
protocols. Fast retransmit is used when three duplicate acks are received. 

The timeout timer is set according to a delay value equal to estimated RTT + 4*deviation. When 
a timeout occurs, the estimated RTT is doubled according to the timer back-off specification 
in the TCP RFCs. A lower limit of 500 ms is set on the timer to avoid excessive retransmission.
This is half the recommended limit in the RFCs, which specifies 1 second, as waiting for 1s often
proved tedious.

On the receiver side, the receiver buffers any packets with a sequence number greater than the next
expected, and immedietly sends an ACK in order to initiate the fast retransmission protocol. If the 
packet received is in order, wait up to 200 ms for a second packet to arrive, then ack both at once.

##Plotting CWND.csv

The CWND.csv is automatically generated by the sender, and consists of 3 columns: time elapsed in
milliseconds, CWND, and the ssthreshold. To plot the congestion window, simply run the python script 
Plotting_CWND.py. in the same directory as the CWND.csv. By default, CWND.csv is output into 
the same file as the rdt_sender file, which is compiled in a seperate obj directory.
Therefore, Plotting_CWND.py would have to be moved to the obj directory.

##Plotting throughput

For plotting throughput, I used helpful.py. To obtain the experiment file, simply redirect the stderr
output of the receiver using 2> to a file ending with _receiver.csv. This was then plotted along with
the tracefile. In order and buffered packages are included in the throughput, but not duplicate packages.

##Testing

For testing, 5 files of various sizes and types were used, and their MD5 hashes were compared. In
all tests, the MD5 hashes were identical. Additionally, CWND, timeout delays, and occurences of
timeouts and retransmissions were all output and compared to ensure that they all lined up and 
made logical sense. All outputs were as to be expected, e.g. when a retransmission occurent, CWND
was set to 1 and ssthreshold was set to max((CWND/2), 2).

##Known Issues

There is currently a memory leak that is detected by valgrind, the origin of which I was unable
to determine. It does not, however, affect the performance of the program. No other issues are
known of at the moment.

